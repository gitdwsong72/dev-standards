from fastapi import APIRouter, HTTPException, Depends, Query, status
from pydantic import BaseModel, ConfigDict, Field
from typing import Annotated
from uuid import UUID, uuid4
from datetime import datetime

router = APIRouter(prefix="/api/v1/{resource}", tags=["{resource}"])


# =============================================================================
# Schemas
# =============================================================================

class {model}Base(BaseModel):
    """Base schema for {model}."""
    name: str = Field(..., min_length=1, max_length=100, examples=["Sample Name"])
    # Add more fields here


class {model}Create({model}Base):
    """Schema for creating {model}."""
    pass


class {model}Update(BaseModel):
    """Schema for updating {model}. All fields optional."""
    name: str | None = Field(None, min_length=1, max_length=100)
    # Add more fields here


class {model}Response({model}Base):
    """Schema for {model} response."""
    id: UUID
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


# =============================================================================
# Repository (In-Memory - Replace with Database)
# =============================================================================

class {model}Repository:
    """In-memory {resource_singular} repository. Replace with database implementation."""

    def __init__(self) -> None:
        self._db: dict[UUID, dict] = {{}}

    def get_all(self, skip: int = 0, limit: int = 100) -> list[dict]:
        items = list(self._db.values())
        return items[skip:skip + limit]

    def get_by_id(self, {resource_singular}_id: UUID) -> dict | None:
        return self._db.get({resource_singular}_id)

    def create(self, data: dict) -> dict:
        {resource_singular}_id = uuid4()
        now = datetime.now()
        item = {{"id": {resource_singular}_id, "created_at": now, "updated_at": now, **data}}
        self._db[{resource_singular}_id] = item
        return item

    def update(self, {resource_singular}_id: UUID, data: dict) -> dict | None:
        if {resource_singular}_id not in self._db:
            return None
        self._db[{resource_singular}_id].update(data)
        self._db[{resource_singular}_id]["updated_at"] = datetime.now()
        return self._db[{resource_singular}_id]

    def delete(self, {resource_singular}_id: UUID) -> dict | None:
        return self._db.pop({resource_singular}_id, None)

    def count(self) -> int:
        return len(self._db)


# Singleton instance (replace with proper DI in production)
_{resource_singular}_repo = {model}Repository()


def get_{resource_singular}_repository() -> {model}Repository:
    """Dependency injection for {resource_singular} repository."""
    return _{resource_singular}_repo


# Type alias for dependency injection
{model}RepoDep = Annotated[{model}Repository, Depends(get_{resource_singular}_repository)]


# =============================================================================
# Endpoints
# =============================================================================

@router.get("/", response_model=list[{model}Response])
async def list_{resource}(
    repo: {model}RepoDep,
    skip: int = Query(0, ge=0, description="Number of items to skip"),
    limit: int = Query(100, ge=1, le=1000, description="Number of items to return"),
):
    """List all {resource} with pagination."""
    return repo.get_all(skip=skip, limit=limit)


@router.get("/{{{resource_singular}_id}}", response_model={model}Response)
async def get_{resource_singular}({resource_singular}_id: UUID, repo: {model}RepoDep):
    """Get a single {resource_singular} by ID."""
    item = repo.get_by_id({resource_singular}_id)
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{model} with id '{{{resource_singular}_id}}' not found"
        )
    return item


@router.post("/", response_model={model}Response, status_code=status.HTTP_201_CREATED)
async def create_{resource_singular}(payload: {model}Create, repo: {model}RepoDep):
    """Create a new {resource_singular}."""
    return repo.create(payload.model_dump())


@router.put("/{{{resource_singular}_id}}", response_model={model}Response)
async def update_{resource_singular}({resource_singular}_id: UUID, payload: {model}Update, repo: {model}RepoDep):
    """Update an existing {resource_singular} (partial update supported)."""
    update_data = payload.model_dump(exclude_unset=True)
    if not update_data:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No fields to update"
        )

    item = repo.update({resource_singular}_id, update_data)
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{model} with id '{{{resource_singular}_id}}' not found"
        )
    return item


@router.delete("/{{{resource_singular}_id}}", response_model={model}Response)
async def delete_{resource_singular}({resource_singular}_id: UUID, repo: {model}RepoDep):
    """Delete a {resource_singular} and return the deleted data."""
    item = repo.delete({resource_singular}_id)
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"{model} with id '{{{resource_singular}_id}}' not found"
        )
    return item
