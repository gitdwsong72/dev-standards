#!/bin/sh

#######################################
# Pre-commit Hook - Fast Developer Feedback
#
# Target: < 5 seconds
# Strategy: Only check staged files, auto-fix when possible
#######################################

# Colors (only if terminal supports it)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' NC=''
fi

ERRORS=0
WARNINGS=0
START_TIME=$(date +%s)

log_pass() { printf "${GREEN}✓${NC} %s\n" "$1"; }
log_fail() { printf "${RED}✗${NC} %s\n" "$1"; ERRORS=$((ERRORS + 1)); }
log_warn() { printf "${YELLOW}⚠${NC} %s\n" "$1"; WARNINGS=$((WARNINGS + 1)); }
log_skip() { printf "  %s (skipped)\n" "$1"; }

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo "No staged files to check."
    exit 0
fi

printf "\n Pre-commit checks\n\n"

#######################################
# 1. Bash syntax check (staged .sh files)
#######################################
STAGED_SH=$(echo "$STAGED_FILES" | grep '\.sh$' || true)

if [ -n "$STAGED_SH" ]; then
    sh_errors=0
    for file in $STAGED_SH; do
        if [ -f "$file" ]; then
            if ! bash -n "$file" 2>/dev/null; then
                log_fail "Bash syntax error: $file"
                sh_errors=1
            fi
        fi
    done
    if [ "$sh_errors" -eq 0 ]; then
        log_pass "Bash syntax check ($(echo "$STAGED_SH" | wc -l | tr -d ' ') files)"
    fi

    # Shellcheck (if available, non-blocking warning)
    if command -v shellcheck >/dev/null 2>&1; then
        sc_errors=0
        for file in $STAGED_SH; do
            if [ -f "$file" ]; then
                if ! shellcheck -S error "$file" 2>/dev/null; then
                    sc_errors=1
                fi
            fi
        done
        if [ "$sc_errors" -eq 0 ]; then
            log_pass "Shellcheck (errors only)"
        else
            log_warn "Shellcheck found issues (run 'scripts/lint-bash.sh' for details)"
        fi
    else
        log_skip "Shellcheck (not installed)"
    fi
else
    log_skip "Bash checks (no .sh files staged)"
fi

#######################################
# 2. Python lint + auto-fix (staged .py files)
#######################################
STAGED_PY=$(echo "$STAGED_FILES" | grep '\.py$' || true)

if [ -n "$STAGED_PY" ]; then
    if command -v ruff >/dev/null 2>&1; then
        # Auto-fix with ruff (format + lint fix)
        py_list=""
        for file in $STAGED_PY; do
            if [ -f "$file" ]; then
                py_list="$py_list $file"
            fi
        done

        if [ -n "$py_list" ]; then
            # Auto-format and re-stage
            # shellcheck disable=SC2086
            if ruff format $py_list 2>/dev/null; then
                # shellcheck disable=SC2086
                ruff check --fix $py_list 2>/dev/null || true
                # Re-stage auto-fixed files
                # shellcheck disable=SC2086
                git add $py_list 2>/dev/null
                log_pass "Python format + lint auto-fix (ruff)"
            fi

            # Final lint check (errors only)
            # shellcheck disable=SC2086
            if ruff check $py_list 2>/dev/null; then
                log_pass "Python lint check"
            else
                log_fail "Python lint errors remain (run 'ruff check --fix' manually)"
            fi
        fi
    else
        log_skip "Python lint (ruff not installed)"
    fi
else
    log_skip "Python checks (no .py files staged)"
fi

#######################################
# 3. JavaScript/TypeScript lint (staged .js/.ts files)
#######################################
STAGED_JS=$(echo "$STAGED_FILES" | grep -E '\.(js|ts|jsx|tsx)$' || true)

if [ -n "$STAGED_JS" ]; then
    if command -v npx >/dev/null 2>&1 && [ -f "node_modules/.bin/eslint" ]; then
        js_list=""
        for file in $STAGED_JS; do
            if [ -f "$file" ]; then
                js_list="$js_list $file"
            fi
        done

        if [ -n "$js_list" ]; then
            # Auto-fix and re-stage
            # shellcheck disable=SC2086
            if npx eslint --fix $js_list 2>/dev/null; then
                # shellcheck disable=SC2086
                git add $js_list 2>/dev/null
                log_pass "JS/TS lint auto-fix (eslint)"
            else
                log_fail "JS/TS lint errors remain (run 'npx eslint --fix' manually)"
            fi
        fi
    else
        log_skip "JS/TS lint (eslint not available)"
    fi
else
    log_skip "JS/TS checks (no .js/.ts files staged)"
fi

#######################################
# 4. Markdown structure check (staged .md files)
#######################################
STAGED_MD=$(echo "$STAGED_FILES" | grep '\.md$' || true)

if [ -n "$STAGED_MD" ]; then
    md_errors=0
    for file in $STAGED_MD; do
        if [ -f "$file" ]; then
            # Check for empty files
            if [ ! -s "$file" ]; then
                log_fail "Empty markdown file: $file"
                md_errors=1
            fi
        fi
    done
    if [ "$md_errors" -eq 0 ]; then
        log_pass "Markdown file check ($(echo "$STAGED_MD" | wc -l | tr -d ' ') files)"
    fi
else
    log_skip "Markdown checks (no .md files staged)"
fi

#######################################
# 5. Prevent committing sensitive files
#######################################
SENSITIVE_PATTERNS=".env .env.local .env.production credentials.json secrets.yaml id_rsa .pem"
sensitive_found=0

for pattern in $SENSITIVE_PATTERNS; do
    match=$(echo "$STAGED_FILES" | grep -E "(^|/)${pattern}$" || true)
    if [ -n "$match" ]; then
        log_fail "Sensitive file staged: $match"
        sensitive_found=1
    fi
done

if [ "$sensitive_found" -eq 0 ]; then
    log_pass "No sensitive files detected"
fi

#######################################
# 6. Large file check (> 1MB)
#######################################
large_found=0
for file in $STAGED_FILES; do
    if [ -f "$file" ]; then
        size=$(wc -c < "$file" 2>/dev/null | tr -d ' ')
        if [ "$size" -gt 1048576 ] 2>/dev/null; then
            log_warn "Large file ($(( size / 1024 ))KB): $file"
            large_found=1
        fi
    fi
done

if [ "$large_found" -eq 0 ]; then
    log_pass "No large files (> 1MB)"
fi

#######################################
# Summary
#######################################
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

echo ""
if [ "$ERRORS" -gt 0 ]; then
    printf "${RED}✗ Pre-commit failed${NC} (%d errors, %d warnings) in %ds\n" "$ERRORS" "$WARNINGS" "$DURATION"
    echo ""
    echo "  Fix errors and try again, or bypass with: git commit --no-verify"
    echo ""
    exit 1
else
    if [ "$WARNINGS" -gt 0 ]; then
        printf "${YELLOW}⚠ Pre-commit passed with warnings${NC} (%d warnings) in %ds\n" "$WARNINGS" "$DURATION"
    else
        printf "${GREEN}✓ Pre-commit passed${NC} in %ds\n" "$DURATION"
    fi
    echo ""
    exit 0
fi
